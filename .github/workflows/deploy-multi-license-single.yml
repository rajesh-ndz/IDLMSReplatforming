name: Deploy Multi License API with Rollback Options (single)

on:
  workflow_dispatch:
    inputs:
      ENV:
        description: "Environment to deploy (dev/stage/prod)"
        required: true
        default: "stage"
      ROLLBACK_TAG:
        description: "If set (latest or 2025.06.30.002), deploy that tag without building"
        required: false
      GIT_REF:
        description: "Git ref/branch to use for code & TF"
        required: false
        default: "main"

env:
  AWS_REGION: ${{ vars.AWS_REGION }}   # e.g. ap-south-1
  TF_BUCKET: test-s3-idlmreplatforming-tfstate

permissions:
  id-token: write
  contents: read

concurrency:
  group: deploy-single-${{ github.event.inputs.ENV }}
  cancel-in-progress: false

jobs:
  build_image:
    if: ${{ !github.event.inputs.ROLLBACK_TAG }}
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.ENV }}
    outputs:
      build_tag: ${{ steps.tags.outputs.BUILD_TAG }}
      image_uri: ${{ steps.tags.outputs.IMAGE_URI }}
      latest_uri: ${{ steps.tags.outputs.LATEST_URI }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.GIT_REF }}

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Detect TF backend region (for TF_BUCKET)
        id: detect_tf_backend
        shell: bash
        run: |
          set -euo pipefail
          LOC="$(aws s3api get-bucket-location --bucket "${TF_BUCKET}" --query 'LocationConstraint' --output text || true)"
          case "$LOC" in None) LOC="us-east-1" ;; EU) LOC="eu-west-1" ;; esac
          [ -z "$LOC" ] || [ "$LOC" = "null" ] && { echo "::error::TF bucket region not found"; exit 1; }
          echo "TF_BACKEND_REGION=$LOC" >> "$GITHUB_ENV"

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.5.0
          terraform_wrapper: false

      - name: Write ECR tfvars
        shell: bash
        run: |
          mkdir -p infra/ecr
          cat > "infra/ecr/${{ github.event.inputs.ENV }}.tfvars" <<EOF
          environment          = "${{ github.event.inputs.ENV }}"
          region               = "${{ env.AWS_REGION }}"
          image_tag_mutability = "MUTABLE"
          scan_on_push         = true
          encryption_type      = "AES256"
          EOF

      - name: Ensure/Output ECR repo
        id: ecr
        shell: bash
        run: |
          set -euo pipefail
          terraform -chdir=infra/ecr init \
            -backend-config="bucket=${TF_BUCKET}" \
            -backend-config="key=${{ github.event.inputs.ENV }}/ecr/terraform.tfstate" \
            -backend-config="region=${TF_BACKEND_REGION}"
          terraform -chdir=infra/ecr apply -auto-approve -var-file="${{ github.event.inputs.ENV }}.tfvars"
          ECR_REPO_URL="$(terraform -chdir=infra/ecr output -raw ecr_repository_url | tr -d '\r')"
          echo "ECR_REPO_URL=$ECR_REPO_URL" >> "$GITHUB_ENV"

      - name: Log in to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Generate build tags
        id: tags
        shell: bash
        run: |
          set -euo pipefail
          ECR_REPO_URL="${{ env.ECR_REPO_URL }}"
          DATE_TAG="$(date -u +'%Y.%m.%d')"
          BUILD_NUM="$(printf "%03d" "$GITHUB_RUN_NUMBER")"
          BUILD_TAG="${DATE_TAG}.${BUILD_NUM}"
          IMAGE_URI="${ECR_REPO_URL}:${BUILD_TAG}"
          LATEST_URI="${ECR_REPO_URL}:latest"
          {
            echo "BUILD_TAG=$BUILD_TAG"
            echo "IMAGE_URI=$IMAGE_URI"
            echo "LATEST_URI=$LATEST_URI"
          } | tee -a "$GITHUB_ENV" >> "$GITHUB_OUTPUT"

      - name: Build and tag Docker image
        shell: bash
        run: docker build -t "$IMAGE_URI" -t "$LATEST_URI" -f docker/Dockerfile src

      - name: Push Docker images to ECR
        shell: bash
        run: |
          docker push "$IMAGE_URI"
          docker push "$LATEST_URI"

  deploy:
    runs-on: ubuntu-latest
    needs: [build_image]
    if: ${{ always() }}
    environment: ${{ github.event.inputs.ENV }}
    outputs:
      tag_to_deploy: ${{ steps.decide.outputs.TAG_TO_DEPLOY }}
      ecr_repo_url: ${{ steps.ecr_url.outputs.ECR_REPO_URL }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.GIT_REF }}

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Map platform-main state bucket per ENV
        id: map_platform_bucket
        shell: bash
        run: |
          set -euo pipefail
          case "${{ github.event.inputs.ENV }}" in
            dev)   B="dev-btl-idlms-repo-backend-api-tfstate-592776312448" ;;
            stage) B="stage-btl-idlms-repo-backend-api-tfstate-592776312448" ;;
            prod)  B="prod-btl-idlms-repo-backend-api-tfstate-592776312448" ;;
            *)     echo "::error::Unknown ENV"; exit 1 ;;
          esac
          echo "PLATFORM_STATE_BUCKET=$B" >> "$GITHUB_ENV"

      - name: Detect platform-main state region
        id: detect_platform_region
        shell: bash
        run: |
          set -euo pipefail
          B="$PLATFORM_STATE_BUCKET"
          LOC="$(aws s3api get-bucket-location --bucket "$B" --query 'LocationConstraint' --output text || true)"
          case "$LOC" in None) LOC="us-east-1" ;; EU) LOC="eu-west-1" ;; esac
          [ -z "$LOC" ] || [ "$LOC" = "null" ] && { echo "::error::Platform bucket region not found"; exit 1; }
          echo "PLATFORM_STATE_REGION=$LOC" >> "$GITHUB_ENV"

      - name: Read INSTANCE_ID from platform tfstate
        shell: bash
        run: |
          set -euo pipefail
          ENV_IN="${{ github.event.inputs.ENV }}"
          B="$PLATFORM_STATE_BUCKET"
          R="$PLATFORM_STATE_REGION"
          mkdir -p /tmp/idlms_state
          aws s3api get-object --bucket "$B" --key "${ENV_IN}/compute/terraform.tfstate" /tmp/idlms_state/compute.json --region "$R" >/dev/null
          INSTANCE_ID="$(jq -r '.outputs.instance_id.value // empty' /tmp/idlms_state/compute.json)"
          [ -z "$INSTANCE_ID" ] && { echo "::error::INSTANCE_ID not found in platform state"; exit 1; }
          echo "INSTANCE_ID=$INSTANCE_ID" >> "$GITHUB_ENV"

      - name: Detect TF backend region (for TF_BUCKET)
        id: detect_tf_backend_deploy
        shell: bash
        run: |
          set -euo pipefail
          LOC="$(aws s3api get-bucket-location --bucket "${TF_BUCKET}" --query 'LocationConstraint' --output text || true)"
          case "$LOC" in None) LOC="us-east-1" ;; EU) LOC="eu-west-1" ;; esac
          [ -z "$LOC" ] || [ "$LOC" = "null" ] && { echo "::error::TF bucket region not found"; exit 1; }
          echo "TF_BACKEND_REGION=$LOC" >> "$GITHUB_ENV"

      - name: Resolve ECR repository URL (from this repo's ecr tfstate)
        id: ecr_url
        shell: bash
        run: |
          set -euo pipefail
          ENV_IN="${{ github.event.inputs.ENV }}"
          KEY="${ENV_IN}/ecr/terraform.tfstate"
          TMP="/tmp/ecr.tfstate.json"
          if aws s3api head-object --bucket "${TF_BUCKET}" --key "$KEY" --region "${TF_BACKEND_REGION}" >/dev/null 2>&1; then
            aws s3api get-object --bucket "${TF_BUCKET}" --key "$KEY" "$TMP" --region "${TF_BACKEND_REGION}" >/dev/null
            URL="$(jq -r '.outputs.ecr_repository_url.value // empty' "$TMP" || true)"
          else
            URL=""
          fi
          [ -z "$URL" ] && { echo "::error::ECR repository URL not found. Ensure build_image ran successfully at least once."; exit 1; }
          echo "ECR_REPO_URL=$URL" >> "$GITHUB_ENV"
          echo "ECR_REPO_URL=$URL" >> "$GITHUB_OUTPUT"
          echo "Using ECR: $URL"

      - name: Log in to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Decide tag to deploy
        id: decide
        shell: bash
        run: |
          set -euo pipefail
          if [ -n "${{ github.event.inputs.ROLLBACK_TAG }}" ]; then
            TAG="${{ github.event.inputs.ROLLBACK_TAG }}"
          elif [ -n "${{ needs.build_image.outputs.build_tag }}" ]; then
            TAG="${{ needs.build_image.outputs.build_tag }}"
          else
            TAG="latest"
          fi
          echo "TAG_TO_DEPLOY=$TAG" | tee -a "$GITHUB_OUTPUT" >> "$GITHUB_ENV"
          echo "Deploying tag: $TAG"

      - name: Deploy containers via SSM (atomic, rollback, record last-good) + logs
        shell: bash
        run: |
          set -euo pipefail
          TAG="${{ steps.decide.outputs.TAG_TO_DEPLOY }}"
          ENV_NAME="${{ github.event.inputs.ENV }}"
          IMAGE_REPO="${{ env.ECR_REPO_URL }}"
          REGION="${{ env.AWS_REGION }}"
          INSTANCE="${{ env.INSTANCE_ID }}"

          if [ -z "$IMAGE_REPO" ]; then
            echo "::error::ECR_REPO_URL not set"; exit 1
          fi

          # Ensure compose file exists in repo; embed it for the instance
          if [ ! -f docker/docker-compose.yml ]; then
            echo "::error::docker/docker-compose.yml not found in repo"
            exit 1
          fi
          COMPOSE_B64="$(base64 -w 0 docker/docker-compose.yml)"

          # No local expansion; placeholders replaced below
          cat > ssm-deploy.json <<'JSON'
          {
            "commands": [
              "set -euo pipefail",
              "cd /home/ubuntu",

              "echo \"__COMPOSE_B64__\" | base64 -d > docker-compose.yml",
              "chown ubuntu:ubuntu docker-compose.yml || true",

              "ENV_NAME=__ENV_NAME__",
              "TAG=__TAG__",
              "IMAGE_REPO=__IMAGE_REPO__",
              "REGION=__REGION__",

              "PARAM=\"/idlms/shared/${ENV_NAME}/.env\"",
              "ENV_CONTENT=$(aws ssm get-parameter --name \"$PARAM\" --with-decryption --query \"Parameter.Value\" --output text || echo '')",
              "printf \"%s\" \"$ENV_CONTENT\" > .env",
              "grep -q '^IMAGE_REPO=' .env && sed -i 's|^IMAGE_REPO=.*|IMAGE_REPO='\"${IMAGE_REPO}\"'|' .env || echo \"IMAGE_REPO=${IMAGE_REPO}\" >> .env",
              "grep -q '^BUILD_TAG=' .env && sed -i 's|^BUILD_TAG=.*|BUILD_TAG='\"${TAG}\"'|' .env || echo \"BUILD_TAG=${TAG}\" >> .env",

              "if docker compose version >/dev/null 2>&1; then DC='docker compose'; elif command -v docker-compose >/dev/null 2>&1; then DC='docker-compose'; else curl -L \"https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose && chmod +x /usr/local/bin/docker-compose && ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose || true; DC='docker-compose'; fi",

              "ECR_HOST=${IMAGE_REPO%%/*}",
              "aws ecr get-login-password --region ${REGION} | docker login --username AWS --password-stdin ${ECR_HOST}",

              "deploy_tag() {",
              "  local tag=\"$1\"",
              "  sed -i 's|^BUILD_TAG=.*|BUILD_TAG='\"${tag}\"'|' .env || true",
              "  echo '--- docker compose config ---'",
              "  ${DC} --env-file .env config || true",
              "  echo '--- docker compose pull ---'",
              "  ${DC} --env-file .env pull --ignore-pull-failures || true",
              "  echo '--- docker compose up -d ---'",
              "  ${DC} --env-file .env up -d --force-recreate || true",
              "  sleep 25",
              "  CNT=$(docker ps --format '{{.Image}} {{.Status}}' | awk -v img=\"${IMAGE_REPO}:${tag}\" '$1==img && $2 ~ /^Up/ {c++} END{print c+0}')",
              "  if [ \"$CNT\" -ge 1 ]; then return 0; else return 1; fi",
              "}",

              "if deploy_tag \"${TAG}\"; then",
              "  echo \"Deployment OK for ${TAG}. Recording last-successful-build...\"",
              "  aws ssm put-parameter --name \"/idlms/license-api/last-successful-build\" --value \"${TAG}\" --type String --overwrite --region ${REGION}",
              "  exit 0",
              "fi",

              "echo 'Deployment failed. Attempting rollback to previous successful tag...' >&2",
              "PREV=$(aws ssm get-parameter --name \"/idlms/license-api/last-successful-build\" --query \"Parameter.Value\" --output text --region ${REGION} 2>/dev/null || echo '')",
              "if [ -n \"$PREV\" ] && [ \"$PREV\" != \"None\" ]; then",
              "  if deploy_tag \"$PREV\"; then echo \"Rollback succeeded to ${PREV}\"; exit 0; fi",
              "fi",

              "echo '------ diagnostics: docker ps -a ------'",
              "docker ps -a --format 'table {{.Names}}\\t{{.Image}}\\t{{.Status}}'",
              "for c in $(docker ps -a --format '{{.Names}}'); do echo \"========== logs: $c ==========\"; docker logs --tail 200 \"$c\" || true; done",
              "exit 1"
            ]
          }
          JSON

          sed -i "s|__ENV_NAME__|${ENV_NAME}|g" ssm-deploy.json
          sed -i "s|__TAG__|${TAG}|g" ssm-deploy.json
          sed -i "s|__IMAGE_REPO__|${IMAGE_REPO}|g" ssm-deploy.json
          sed -i "s|__REGION__|${REGION}|g" ssm-deploy.json
          sed -i "s|__COMPOSE_B64__|${COMPOSE_B64}|g" ssm-deploy.json

          CMD_ID="$(aws ssm send-command \
            --document-name 'AWS-RunShellScript' \
            --instance-ids "${INSTANCE}" \
            --comment "Deploy containers ${ENV_NAME} tag=${TAG}" \
            --parameters file://ssm-deploy.json \
            --query 'Command.CommandId' \
            --output text \
            --region "${REGION}")"

          # Poll and print logs so failures are obvious
          while true; do
            STATUS="$(aws ssm list-command-invocations --command-id "$CMD_ID" --details --query 'CommandInvocations[0].Status' --output text --region "$REGION")"
            case "$STATUS" in Pending|InProgress|Delayed) sleep 5 ;; Success|Cancelled|TimedOut|Failed) break ;; *) sleep 5 ;; esac
          done
          echo "SSM status: $STATUS"
          echo "----- STDOUT -----"
          aws ssm get-command-invocation --command-id "$CMD_ID" --instance-id "$INSTANCE" --region "$REGION" --query 'StandardOutputContent' --output text || true
          echo "----- STDERR -----"
          aws ssm get-command-invocation --command-id "$CMD_ID" --instance-id "$INSTANCE" --region "$REGION" --query 'StandardErrorContent'  --output text || true
          [ "$STATUS" = "Success" ] || { echo "::error::deploy failed"; exit 1; }

  verify:
    name: Post-deploy health check
    runs-on: ubuntu-latest
    needs: deploy
    if: ${{ always() && (needs.build_image.result == 'success' || needs.build_image.result == 'skipped') }}
    environment: ${{ github.event.inputs.ENV }}
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Wait 30 seconds for containers to settle
        shell: bash
        run: sleep 30

      - name: Health check via SSM (match image:tag)
        shell: bash
        run: |
          set -euo pipefail
          ENV_INPUT="${{ github.event.inputs.ENV }}"
          REGION="${{ env.AWS_REGION }}"
          REPO="${{ needs.deploy.outputs.ecr_repo_url }}"
          TAG="${{ needs.deploy.outputs.tag_to_deploy }}"

          if [ -z "$REPO" ] || [ -z "$TAG" ]; then
            echo "::error::Missing repo/tag from deploy outputs"; exit 1
          fi

          INSTANCE_ID="$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=Backend API IDLMS-${ENV_INPUT}" "Name=instance-state-name,Values=running" \
            --query "sort_by(Reservations[].Instances[], &LaunchTime)[-1].InstanceId" \
            --region "$REGION" --output text || true)"
          if [ -z "$INSTANCE_ID" ] || [ "$INSTANCE_ID" = "None" ]; then
            INSTANCE_ID="$(aws ec2 describe-instances \
              --filters "Name=tag:Name,Values=${ENV_INPUT}-idlms-app" "Name=instance-state-name,Values=running" \
              --query "sort_by(Reservations[].Instances[], &LaunchTime)[-1].InstanceId" \
              --region "$REGION" --output text || true)"
          fi
          if [ -z "$INSTANCE_ID" ] || [ "$INSTANCE_ID" = "None" ]; then
            echo "::error::pods not up"; exit 1
          fi

          cat > ssm-check.json <<'JSON'
          {
            "commands": [
              "set -euo pipefail",
              "REPO='__REPO__'",
              "TAG='__TAG__'",
              "CNT=$(docker ps --format '{{.Image}} {{.Status}}' | awk -v img=\"${REPO}:${TAG}\" '$1==img && $2 ~ /^Up/ {c++} END{print c+0}')",
              "if [ \"$CNT\" -ge 1 ]; then echo 'pods up'; exit 0; fi",
              "echo 'pods not up';",
              "docker ps -a --format 'table {{.Names}}\\t{{.Image}}\\t{{.Status}}'",
              "exit 1"
            ]
          }
          JSON
          sed -i "s|__REPO__|${REPO}|g" ssm-check.json
          sed -i "s|__TAG__|${TAG}|g" ssm-check.json

          CMD_ID="$(aws ssm send-command \
            --document-name 'AWS-RunShellScript' \
            --instance-ids "$INSTANCE_ID" \
            --comment 'Post-deploy health check' \
            --parameters file://ssm-check.json \
            --query 'Command.CommandId' \
            --output text \
            --region "$REGION")"

          while true; do
            STATUS="$(aws ssm list-command-invocations --command-id "$CMD_ID" --details --query 'CommandInvocations[0].Status' --output text --region "$REGION")"
            case "$STATUS" in Pending|InProgress|Delayed) sleep 5 ;; Success|Cancelled|TimedOut|Failed) break ;; *) sleep 5 ;; esac
          done
          echo "SSM status: $STATUS"
          aws ssm get-command-invocation --command-id "$CMD_ID" --instance-id "$INSTANCE_ID" --region "$REGION" --query 'StandardOutputContent' --output text || true
          [ "$STATUS" = "Success" ] || { echo "::error::pods not up"; exit 1; }
