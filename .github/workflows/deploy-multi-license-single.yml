name: Deploy Multi License API (reuse platform-main - single)

on:
  workflow_dispatch:
    inputs:
      ENV:
        description: "Environment to deploy (dev/stage/prod)"
        required: true
        default: "stage"
      ROLLBACK_TAG:
        description: "If set (e.g. 2025.08.05.160), deploy that tag without building"
        required: false
      GIT_REF:
        description: "Git ref/branch to use for code"
        required: false
        default: "main"

env:
  AWS_REGION: ${{ vars.AWS_REGION }}

permissions:
  id-token: write
  contents: read

concurrency:
  group: deploy-single-${{ github.event.inputs.ENV }}
  cancel-in-progress: false

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.ENV }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.GIT_REF }}

      - name: Configure AWS creds (same style as before)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ env.AWS_REGION }}
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      - name: Set platform-main state mapping
        shell: bash
        run: |
          set -euo pipefail
          ENV_NAME="${{ github.event.inputs.ENV }}"
          case "$ENV_NAME" in
            dev)
              echo "PLATFORM_STATE_BUCKET=dev-btl-idlms-repo-backend-api-tfstate-592776312448" >> "$GITHUB_ENV"
              echo "PLATFORM_STATE_REGION=${{ env.AWS_REGION }}" >> "$GITHUB_ENV"
              ;;
            stage)
              echo "PLATFORM_STATE_BUCKET=stage-btl-idlms-repo-backend-api-tfstate-592776312448" >> "$GITHUB_ENV"
              echo "PLATFORM_STATE_REGION=${{ env.AWS_REGION }}" >> "$GITHUB_ENV"
              ;;
            prod)
              echo "PLATFORM_STATE_BUCKET=prod-btl-idlms-repo-backend-api-tfstate-592776312448" >> "$GITHUB_ENV"
              echo "PLATFORM_STATE_REGION=${{ env.AWS_REGION }}" >> "$GITHUB_ENV"
              ;;
            *)
              echo "::error::No platform_state_bucket mapping for ENV=$ENV_NAME"; exit 1 ;;
          esac
          echo "ENV_NAME=$ENV_NAME" >> "$GITHUB_ENV"

      - name: Read platform-main outputs (Terraform in repo)
        working-directory: infra/platform-remote
        shell: bash
        run: |
          set -euo pipefail
          terraform init -input=false -upgrade
          terraform apply -input=false -auto-approve \
            -var="env_name=${ENV_NAME}" \
            -var="region=${AWS_REGION}" \
            -var="platform_state_bucket=${PLATFORM_STATE_BUCKET}" \
            -var="platform_state_region=${PLATFORM_STATE_REGION}"
          terraform output -json > /tmp/platform_outputs.json

          echo "INSTANCE_ID=$(jq -r '.instance_id.value // empty' /tmp/platform_outputs.json)" >> "$GITHUB_ENV"
          echo "ECR_REPOSITORY_URL=$(jq -r '.ecr_repository_url.value // empty' /tmp/platform_outputs.json)" >> "$GITHUB_ENV"
          echo "APIGW_INVOKE_URL=$(jq -r '.apigw_invoke_url.value // empty' /tmp/platform_outputs.json)" >> "$GITHUB_ENV"
          echo "APIGW_STAGE=$(jq -r '.apigw_stage_name.value // empty' /tmp/platform_outputs.json)" >> "$GITHUB_ENV"

      - name: Build & Push image (when not rolling back)
        if: ${{ !github.event.inputs.ROLLBACK_TAG }}
        shell: bash
        run: |
          set -euo pipefail
          if [ -z "${ECR_REPOSITORY_URL:-}" ]; then
            echo "::error::ECR_REPOSITORY_URL is empty (check platform-main ecr outputs)"; exit 1
          fi
          # login to ECR
          aws ecr get-login-password --region "${AWS_REGION}" \
            | docker login --username AWS --password-stdin "$(echo "$ECR_REPOSITORY_URL" | cut -d'/' -f1)"

          # tag format: YYYY.MM.DD.HHMM (UTC)
          TAG="$(date -u +'%Y.%m.%d.%H%M')"
          IMAGE="${ECR_REPOSITORY_URL}:${TAG}"
          LATEST="${ECR_REPOSITORY_URL}:latest"

          docker build -t "$IMAGE" -t "$LATEST" .
          docker push "$IMAGE"
          docker push "$LATEST"

          echo "DEPLOY_TAG=$TAG" >> "$GITHUB_ENV"

      - name: Use rollback tag (skip build)
        if: ${{ github.event.inputs.ROLLBACK_TAG }}
        shell: bash
        run: echo "DEPLOY_TAG=${{ github.event.inputs.ROLLBACK_TAG }}" >> "$GITHUB_ENV"

      - name: Deploy on EC2 via SSM
        shell: bash
        run: |
          set -euo pipefail
          if [ -z "${INSTANCE_ID:-}" ] || [ -z "${ECR_REPOSITORY_URL:-}" ] || [ -z "${DEPLOY_TAG:-}" ]; then
            echo "::error::Missing INSTANCE_ID/ECR_REPOSITORY_URL/DEPLOY_TAG"; exit 1
          fi

          # Build remote script with variables inlined here
          cat > /tmp/deploy.sh <<SCRIPT
          set -euo pipefail
          ENV_NAME="${ENV_NAME}"
          ECR_URL="${ECR_REPOSITORY_URL}"
          TAG="${DEPLOY_TAG}"

          REG="\$(echo "\$ECR_URL" | cut -d'.' -f4)"
          ACC="\$(echo "\$ECR_URL" | cut -d'.' -f1)"

          # Fetch app .env from SSM (adjust path if you use a different one)
          SSM_ENV_PATH="/idlms/shared/${ENV_NAME}/.env"
          mkdir -p /opt/idlms
          if aws ssm get-parameter --name "\$SSM_ENV_PATH" --with-decryption --query Parameter.Value --output text >/tmp/app.env 2>/dev/null; then
            mv /tmp/app.env /opt/idlms/.env
          fi

          # ECR login + pull
          aws ecr get-login-password --region "\$REG" | docker login --username AWS --password-stdin "\${ACC}.dkr.ecr.\${REG}.amazonaws.com"
          docker pull "\${ECR_URL}:\${TAG}"

          # Use docker-compose if present; else run single container
          if [ -f /opt/idlms/docker-compose.yml ]; then
            sed -i "s|image: .*|image: \${ECR_URL}:\${TAG}|g" /opt/idlms/docker-compose.yml
            docker compose -f /opt/idlms/docker-compose.yml up -d
          else
            docker rm -f idlms || true
            if [ -f /opt/idlms/.env ]; then
              docker run -d --name idlms --env-file /opt/idlms/.env -p 4000:4000 "\${ECR_URL}:\${TAG}"
            else
              docker run -d --name idlms -p 4000:4000 "\${ECR_URL}:\${TAG}"
            fi
          fi
          SCRIPT

          # send & execute
          CMD_ID="$(aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --comment "IDLMS Deploy ${ENV_NAME} tag=${DEPLOY_TAG}" \
            --parameters commands="$(cat /tmp/deploy.sh)" \
            --query 'Command.CommandId' \
            --output text)"
          echo "SSM Command: $CMD_ID"

          # Optional: wait & print status
          while true; do
            STATUS="$(aws ssm list-command-invocations \
              --command-id "$CMD_ID" \
              --details \
              --query 'CommandInvocations[0].Status' \
              --output text)"
            case "$STATUS" in
              Pending|InProgress|Delayed) sleep 5 ;;
              Success|Cancelled|TimedOut|Failed) break ;;
              *) sleep 5 ;;
            esac
          done
          echo "SSM status: $STATUS"
          if [ "$STATUS" != "Success" ]; then
            echo "::error::Deploy failed on instance"
            exit 1
          fi
