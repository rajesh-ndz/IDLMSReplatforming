name: Deploy Multi License API with Rollback Options (single)

on:
  workflow_dispatch:
    inputs:
      ENV:
        description: "Environment to deploy (dev/stage/prod)"
        required: true
        default: "stage"
      ROLLBACK_TAG:
        description: "If set (latest or 2025.06.30.002), deploy that tag without building"
        required: false
      GIT_REF:
        description: "Git ref/branch to use for code & TF"
        required: false
        default: "main"

env:
  AWS_REGION: ${{ vars.AWS_REGION }}
  TF_BUCKET: test-s3-idlmreplatforming-tfstate

permissions:
  id-token: write
  contents: read

concurrency:
  group: deploy-single-${{ github.event.inputs.ENV }}
  cancel-in-progress: false

jobs:
  build_image:
    if: ${{ !github.event.inputs.ROLLBACK_TAG }}
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.ENV }}
    outputs:
      build_tag: ${{ steps.tags.outputs.BUILD_TAG }}
      image_uri: ${{ steps.tags.outputs.IMAGE_URI }}
      latest_uri: ${{ steps.tags.outputs.LATEST_URI }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.GIT_REF }}

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Detect TF backend region (for TF_BUCKET)
        id: detect_tf_backend
        shell: bash
        run: |
          set -euo pipefail
          LOC="$(aws s3api get-bucket-location --bucket "${TF_BUCKET}" --query 'LocationConstraint' --output text || true)"
          case "$LOC" in
            None) LOC="us-east-1" ;;
            EU)   LOC="eu-west-1" ;;
          esac
          if [ -z "$LOC" ] || [ "$LOC" = "null" ]; then
            echo "::error::Could not detect region for bucket ${TF_BUCKET}"
            exit 1
          fi
          echo "TF_BACKEND_REGION=$LOC" >> "$GITHUB_ENV"

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.5.0
          terraform_wrapper: false

      - name: Write ECR tfvars
        shell: bash
        run: |
          mkdir -p infra/ecr
          cat > "infra/ecr/${{ github.event.inputs.ENV }}.tfvars" <<EOF
          environment          = "${{ github.event.inputs.ENV }}"
          region               = "${{ env.AWS_REGION }}"
          image_tag_mutability = "MUTABLE"
          scan_on_push         = true
          encryption_type      = "AES256"
          EOF

      - name: Ensure/Output ECR repo
        id: ecr
        shell: bash
        run: |
          set -euo pipefail
          terraform -chdir=infra/ecr init \
            -backend-config="bucket=${TF_BUCKET}" \
            -backend-config="key=${{ github.event.inputs.ENV }}/ecr/terraform.tfstate" \
            -backend-config="region=${TF_BACKEND_REGION}"
          terraform -chdir=infra/ecr apply -auto-approve -var-file="${{ github.event.inputs.ENV }}.tfvars"
          ECR_REPO_URL="$(terraform -chdir=infra/ecr output -raw ecr_repository_url | tr -d '\r')"
          echo "ECR_REPO_URL=$ECR_REPO_URL" >> "$GITHUB_ENV"

      - name: Log in to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Generate build tags
        id: tags
        shell: bash
        run: |
          set -euo pipefail
          ECR_REPO_URL="${{ env.ECR_REPO_URL }}"
          DATE_TAG="$(date -u +'%Y.%m.%d')"
          BUILD_NUM="$(printf "%03d" "$GITHUB_RUN_NUMBER")"
          BUILD_TAG="${DATE_TAG}.${BUILD_NUM}"
          IMAGE_URI="${ECR_REPO_URL}:${BUILD_TAG}"
          LATEST_URI="${ECR_REPO_URL}:latest"
          {
            echo "BUILD_TAG=$BUILD_TAG"
            echo "IMAGE_URI=$IMAGE_URI"
            echo "LATEST_URI=$LATEST_URI"
          } | tee -a "$GITHUB_ENV" >> "$GITHUB_OUTPUT"

      - name: Build and tag Docker image
        shell: bash
        run: docker build -t "$IMAGE_URI" -t "$LATEST_URI" -f docker/Dockerfile src

      - name: Push Docker images to ECR
        shell: bash
        run: |
          docker push "$IMAGE_URI"
          docker push "$LATEST_URI"

  deploy:
    runs-on: ubuntu-latest
    needs: [build_image]
    if: ${{ always() }}
    environment: ${{ github.event.inputs.ENV }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.GIT_REF }}

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Map platform-main state bucket per ENV
        id: map_platform_bucket
        shell: bash
        run: |
          set -euo pipefail
          case "${{ github.event.inputs.ENV }}" in
            dev)
              echo "PLATFORM_STATE_BUCKET=dev-btl-idlms-repo-backend-api-tfstate-592776312448" >> "$GITHUB_ENV"
              ;;
            stage)
              echo "PLATFORM_STATE_BUCKET=stage-btl-idlms-repo-backend-api-tfstate-592776312448" >> "$GITHUB_ENV"
              ;;
            prod)
              echo "PLATFORM_STATE_BUCKET=prod-btl-idlms-repo-backend-api-tfstate-592776312448" >> "$GITHUB_ENV"
              ;;
            *)
              echo "::error::Unknown ENV"; exit 1 ;;
          esac

      - name: Detect platform-main state region
        id: detect_platform_region
        shell: bash
        run: |
          set -euo pipefail
          B="$PLATFORM_STATE_BUCKET"
          LOC="$(aws s3api get-bucket-location --bucket "$B" --query 'LocationConstraint' --output text || true)"
          case "$LOC" in
            None) LOC="us-east-1" ;;
            EU)   LOC="eu-west-1" ;;
          esac
          if [ -z "$LOC" ] || [ "$LOC" = "null" ]; then
            echo "::error::Could not detect region for bucket $B"
            exit 1
          fi
          echo "PLATFORM_STATE_REGION=$LOC" >> "$GITHUB_ENV"

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.5.0
        # terraform_wrapper default is true here; okay for read-only apply

      - name: Read platform-main outputs
        working-directory: infra/platform-remote
        shell: bash
        run: |
          set -euo pipefail
          terraform init -input=false -upgrade
          terraform apply -input=false -auto-approve \
            -var="env_name=${{ github.event.inputs.ENV }}" \
            -var="region=${AWS_REGION}" \
            -var="platform_state_bucket=${PLATFORM_STATE_BUCKET}" \
            -var="platform_state_region=${PLATFORM_STATE_REGION}"
          terraform output -json > /tmp/platform_outputs.json
          echo "INSTANCE_ID=$(jq -r '.instance_id.value // empty' /tmp/platform_outputs.json)" >> "$GITHUB_ENV"

      - name: Log in to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Decide tag to deploy
        id: decide
        shell: bash
        run: |
          set -euo pipefail
          if [ -n "${{ github.event.inputs.ROLLBACK_TAG }}" ]; then
            TAG="${{ github.event.inputs.ROLLBACK_TAG }}"
          elif [ -n "${{ needs.build_image.outputs.build_tag }}" ]; then
            TAG="${{ needs.build_image.outputs.build_tag }}"
          else
            TAG="latest"
          fi
          echo "TAG_TO_DEPLOY=$TAG" | tee -a "$GITHUB_OUTPUT" >> "$GITHUB_ENV"

      - name: Resolve EC2 instance (fallback)
        id: resolve_ec2
        shell: bash
        run: |
          set -euo pipefail
          ENV_INPUT="${{ github.event.inputs.ENV }}"
          REGION="${{ env.AWS_REGION }}"
          if [ -z "${INSTANCE_ID:-}" ] || [ "${INSTANCE_ID}" = "null" ]; then
            INSTANCE_ID="$(aws ec2 describe-instances \
              --filters "Name=tag:Name,Values=Backend API IDLMS-${ENV_INPUT}" "Name=instance-state-name,Values=running" \
              --query "sort_by(Reservations[].Instances[], &LaunchTime)[-1].InstanceId" \
              --region "$REGION" --output text || true)"
          fi
          if [ -z "$INSTANCE_ID" ] || [ "$INSTANCE_ID" = "None" ]; then
            INSTANCE_ID="$(aws ec2 describe-instances \
              --filters "Name=tag:Name,Values=${ENV_INPUT}-idlms-app" "Name=instance-state-name,Values=running" \
              --query "sort_by(Reservations[].Instances[], &LaunchTime)[-1].InstanceId" \
              --region "$REGION" --output text || true)"
          fi
          if [ -z "$INSTANCE_ID" ] || [ "$INSTANCE_ID" = "None" ]; then
            echo "::error::No running EC2 instance found for environment $ENV_INPUT"
            exit 1
          fi
          echo "INSTANCE_ID=$INSTANCE_ID" >> "$GITHUB_ENV"

      - name: Deploy containers via SSM
        shell: bash
        run: |
          set -euo pipefail
          TAG_TO_DEPLOY="${{ steps.decide.outputs.TAG_TO_DEPLOY }}"
          ENV_INPUT="${{ github.event.inputs.ENV }}"
          ECR_REPO_URL="${{ env.ECR_REPO_URL }}"
          AWS_REGION="${{ env.AWS_REGION }}"
          INSTANCE_ID="${{ env.INSTANCE_ID }}"

          cat > ssm-deploy.json <<JSON
          {
            "commands": [
              "set -e",
              "cd /home/ubuntu",
              "ENV_CONTENT=$(aws ssm get-parameter --name \"/idlms/shared/${ENV_INPUT}/.env\" --with-decryption --query \"Parameter.Value\" --output text)",
              "printf \"%s\" \"$ENV_CONTENT\" > .env",
              "echo \"BUILD_TAG=${TAG_TO_DEPLOY}\" >> .env",
              "echo \"IMAGE_REPO=${ECR_REPO_URL}\" >> .env",
              "if ! command -v docker &> /dev/null; then sudo apt-get update -y && sudo apt-get install -y docker.io; fi",
              "if ! command -v docker-compose &> /dev/null; then curl -L \"https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose && chmod +x /usr/local/bin/docker-compose && ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose || true; fi",
              "aws ecr get-login-password --region ${AWS_REGION} | docker login --username AWS --password-stdin ${ECR_REPO_URL%/*}",
              "docker-compose --env-file .env down || true",
              "docker-compose --env-file .env pull --ignore-pull-failures",
              "docker-compose --env-file .env up -d --force-recreate",
              "sleep 30"
            ]
          }
          JSON

          CMD_ID="$(aws ssm send-command \
            --document-name 'AWS-RunShellScript' \
            --instance-ids "$INSTANCE_ID" \
            --comment "Deploy containers ${ENV_INPUT} tag=${TAG_TO_DEPLOY}" \
            --parameters file://ssm-deploy.json \
            --query 'Command.CommandId' \
            --output text \
            --region "$AWS_REGION")"
          echo "SSM Command: $CMD_ID"

  verify:
    name: Post-deploy health check
    runs-on: ubuntu-latest
    needs: deploy
    if: ${{ always() && (needs.build_image.result == 'success' || needs.build_image.result == 'skipped') }}
    environment: ${{ github.event.inputs.ENV }}
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Wait 45 seconds for containers to settle
        shell: bash
        run: sleep 45

      - name: Health check via SSM
        shell: bash
        run: |
          set -euo pipefail
          ENV_INPUT="${{ github.event.inputs.ENV }}"
          AWS_REGION="${{ env.AWS_REGION }}"
          INSTANCE_ID="$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=Backend API IDLMS-${ENV_INPUT}" "Name=instance-state-name,Values=running" \
            --query "sort_by(Reservations[].Instances[], &LaunchTime)[-1].InstanceId" \
            --region "$AWS_REGION" --output text || true)"
          if [ -z "$INSTANCE_ID" ] || [ "$INSTANCE_ID" = "None" ]; then
            INSTANCE_ID="$(aws ec2 describe-instances \
              --filters "Name=tag:Name,Values=${ENV_INPUT}-idlms-app" "Name=instance-state-name,Values=running" \
              --query "sort_by(Reservations[].Instances[], &LaunchTime)[-1].InstanceId" \
              --region "$AWS_REGION" --output text || true)"
          fi
          if [ -z "$INSTANCE_ID" ] || [ "$INSTANCE_ID" = "None" ]; then
            echo "::error::pods not up"
            exit 1
          fi

          cat > ssm-check.json <<'JSON'
          {
            "commands": [
              "set -e",
              "if ! command -v docker >/dev/null 2>&1; then echo 'pods not up'; exit 1; fi",
              "CNT=$(docker ps --format '{{.Names}} {{.Status}}' | awk '$2 ~ /^Up/ {c++} END{print c+0}')",
              "if [ \"$CNT\" -ge 1 ]; then echo 'pods up'; else echo 'pods not up'; exit 1; fi"
            ]
          }
          JSON

          CMD_ID="$(aws ssm send-command \
            --document-name 'AWS-RunShellScript' \
            --instance-ids "$INSTANCE_ID" \
            --comment 'Post-deploy health check' \
            --parameters file://ssm-check.json \
            --query 'Command.CommandId' \
            --output text \
            --region "$AWS_REGION")"

          while true; do
            STATUS="$(aws ssm list-command-invocations --command-id "$CMD_ID" --details --query 'CommandInvocations[0].Status' --output text --region "$AWS_REGION")"
            case "$STATUS" in
              Pending|InProgress|Delayed) sleep 5 ;;
              Success|Cancelled|TimedOut|Failed) break ;;
              *) sleep 5 ;;
            esac
          done
          echo "SSM status: $STATUS"
          aws ssm get-command-invocation --command-id "$CMD_ID" --instance-id "$INSTANCE_ID" --region "$AWS_REGION" --query 'StandardOutputContent' --output text || true
          if [ "$STATUS" != "Success" ]; then
            echo "::error::pods not up"
            exit 1
          fi
