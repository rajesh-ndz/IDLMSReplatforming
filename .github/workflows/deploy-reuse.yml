name: Deploy Multi License API (reuse platform-main, with rollback)

on:
  workflow_dispatch:
    inputs:
      ENV:
        description: "Environment to deploy (dev/stage/prod)"
        required: true
        default: "stage"
      ROLLBACK_TAG:
        description: "If set (latest or 2025.06.30.002), deploy that tag without building"
        required: false
      GIT_REF:
        description: "Git ref/branch to use for code"
        required: false
        default: "main"

env:
  AWS_REGION: ${{ vars.AWS_REGION }}   # e.g. ap-south-1

permissions:
  id-token: write
  contents: read

concurrency:
  group: deploy-single-${{ github.event.inputs.ENV }}
  cancel-in-progress: false

jobs:
  build_image:
    if: ${{ !github.event.inputs.ROLLBACK_TAG }}
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.ENV }}
    outputs:
      build_tag: ${{ steps.tags.outputs.BUILD_TAG }}
      image_uri: ${{ steps.tags.outputs.IMAGE_URI }}
      latest_uri: ${{ steps.tags.outputs.LATEST_URI }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.GIT_REF }}

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Resolve ECR repo URL (SSM first, tfstate fallback)
        id: ecr_repo
        shell: bash
        run: |
          set -euo pipefail
          ENV_IN="${{ github.event.inputs.ENV }}"
          REGION="${{ env.AWS_REGION }}"
          # 1) Preferred: SSM parameter created by platform-main
          URL="$(aws ssm get-parameter --name "/idlms/ecr/${ENV_IN}/repo_url" --query 'Parameter.Value' --output text --region "$REGION" 2>/dev/null || true)"
          if [ -z "$URL" ] || [ "$URL" = "None" ]; then
            echo "ECR URL not in SSM, trying platform tfstate fallback..."
            # 2) Fallback: read from platform tfstate bucket (adjust names below if your bucket names differ)
            case "$ENV_IN" in
              dev)   B="dev-btl-idlms-backend-api-tfstate" ;;
              stage) B="stage-btl-idlms-backend-api-tfstate" ;;
              prod)  B="prod-btl-idlms-backend-api-tfstate" ;;
              *)     echo "::error::Unknown ENV"; exit 1 ;;
            esac
            LOC="$(aws s3api get-bucket-location --bucket "$B" --query 'LocationConstraint' --output text || true)"
            case "$LOC" in None) LOC="us-east-1" ;; EU) LOC="eu-west-1" ;; esac
            [ -z "$LOC" ] || [ "$LOC" = "null" ] && { echo "::error::Platform bucket region not found"; exit 1; }
            TMP="/tmp/ecr.tfstate.json"
            aws s3api get-object --bucket "$B" --key "${ENV_IN}/ecr/terraform.tfstate" "$TMP" --region "$LOC" >/dev/null
            # Try common output names
            URL="$(jq -r '.outputs.repository_urls.value[0] // .outputs.repository_url.value // .outputs.ecr_repository_url.value // empty' "$TMP" || true)"
          fi
          [ -n "$URL" ] && [ "$URL" != "None" ] || { echo "::error::ECR repository URL not found in SSM or tfstate"; exit 1; }
          echo "ECR_REPO_URL=$URL" | tee -a "$GITHUB_ENV" "$GITHUB_OUTPUT"

      - name: Log in to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Generate build tags
        id: tags
        shell: bash
        run: |
          set -euo pipefail
          ECR_REPO_URL="${{ env.ECR_REPO_URL }}"
          DATE_TAG="$(date -u +'%Y.%m.%d')"
          BUILD_NUM="$(printf "%03d" "$GITHUB_RUN_NUMBER")"
          BUILD_TAG="${DATE_TAG}.${BUILD_NUM}"
          IMAGE_URI="${ECR_REPO_URL}:${BUILD_TAG}"
          LATEST_URI="${ECR_REPO_URL}:latest"
          {
            echo "BUILD_TAG=$BUILD_TAG"
            echo "IMAGE_URI=$IMAGE_URI"
            echo "LATEST_URI=$LATEST_URI"
          } | tee -a "$GITHUB_ENV" >> "$GITHUB_OUTPUT"

      - name: Build and tag Docker image
        shell: bash
        run: docker build -t "${{ env.IMAGE_URI }}" -t "${{ env.LATEST_URI }}" -f docker/Dockerfile src

      - name: Push Docker images to ECR
        shell: bash
        run: |
          docker push "${{ env.IMAGE_URI }}"
          docker push "${{ env.LATEST_URI }}"

  deploy:
    runs-on: ubuntu-latest
    needs: [build_image]
    if: ${{ always() }}
    environment: ${{ github.event.inputs.ENV }}
    outputs:
      tag_to_deploy: ${{ steps.decide.outputs.TAG_TO_DEPLOY }}
      ecr_repo_url: ${{ steps.ecr_url.outputs.ECR_REPO_URL }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.GIT_REF }}

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Resolve INSTANCE_ID (SSM, then tfstate, then tags)
        id: instance
        shell: bash
        run: |
          set -euo pipefail
          ENV_IN="${{ github.event.inputs.ENV }}"
          REGION="${{ env.AWS_REGION }}"

          # 1) Preferred: SSM set by platform-main
          INSTANCE_ID="$(aws ssm get-parameter --name "/idlms/compute/${ENV_IN}/instance_id" --query 'Parameter.Value' --output text --region "$REGION" 2>/dev/null || true)"

          # 2) Fallback: platform tfstate (adjust buckets if different)
          if [ -z "$INSTANCE_ID" ] || [ "$INSTANCE_ID" = "None" ]; then
            case "$ENV_IN" in
              dev)   B="dev-btl-idlms-backend-api-tfstate" ;;
              stage) B="stage-btl-idlms-backend-api-tfstate" ;;
              prod)  B="prod-btl-idlms-backend-api-tfstate" ;;
              *)     echo "::error::Unknown ENV"; exit 1 ;;
            esac
            LOC="$(aws s3api get-bucket-location --bucket "$B" --query 'LocationConstraint' --output text || true)"
            case "$LOC" in None) LOC="us-east-1" ;; EU) LOC="eu-west-1" ;; esac
            [ -z "$LOC" ] || [ "$LOC" = "null" ] && { echo "::error::Platform bucket region not found"; exit 1; }
            TMP="/tmp/compute.tfstate.json"
            aws s3api get-object --bucket "$B" --key "${ENV_IN}/compute/terraform.tfstate" "$TMP" --region "$LOC" >/dev/null
            INSTANCE_ID="$(jq -r '.outputs.instance_id.value // empty' "$TMP" || true)"
          fi

          # 3) Last resort: look up by tags
          if [ -z "$INSTANCE_ID" ] || [ "$INSTANCE_ID" = "None" ]; then
            INSTANCE_ID="$(aws ec2 describe-instances \
              --filters "Name=tag:Name,Values=Backend API IDLMS-${ENV_IN}" "Name=instance-state-name,Values=running" \
              --query "sort_by(Reservations[].Instances[], &LaunchTime)[-1].InstanceId" \
              --region "$REGION" --output text || true)"
          fi

          [ -n "$INSTANCE_ID" ] && [ "$INSTANCE_ID" != "None" ] || { echo "::error::INSTANCE_ID not found"; exit 1; }
          echo "INSTANCE_ID=$INSTANCE_ID" | tee -a "$GITHUB_ENV" "$GITHUB_OUTPUT"

      - name: Resolve ECR repository URL (reuse build output or re-fetch)
        id: ecr_url
        shell: bash
        run: |
          set -euo pipefail
          if [ -n "${{ needs.build_image.outputs.image_uri }}" ]; then
            echo "ECR_REPO_URL=${{ env.ECR_REPO_URL }}" | tee -a "$GITHUB_ENV" "$GITHUB_OUTPUT"
          else
            # If build was skipped (rollback), ensure ECR_REPO_URL exists as in build step
            ENV_IN="${{ github.event.inputs.ENV }}"
            REGION="${{ env.AWS_REGION }}"
            URL="$(aws ssm get-parameter --name "/idlms/ecr/${ENV_IN}/repo_url" --query 'Parameter.Value' --output text --region "$REGION" 2>/dev/null || true)"
            if [ -z "$URL" ] || [ "$URL" = "None" ]; then
              case "$ENV_IN" in
                dev)   B="dev-btl-idlms-backend-api-tfstate" ;;
                stage) B="stage-btl-idlms-backend-api-tfstate" ;;
                prod)  B="prod-btl-idlms-backend-api-tfstate" ;;
                *)     echo "::error::Unknown ENV"; exit 1 ;;
              esac
              LOC="$(aws s3api get-bucket-location --bucket "$B" --query 'LocationConstraint' --output text || true)"
              case "$LOC" in None) LOC="us-east-1" ;; EU) LOC="eu-west-1" ;; esac
              [ -z "$LOC" ] || [ "$LOC" = "null" ] && { echo "::error::Platform bucket region not found"; exit 1; }
              TMP="/tmp/ecr.tfstate.json"
              aws s3api get-object --bucket "$B" --key "${ENV_IN}/ecr/terraform.tfstate" "$TMP" --region "$LOC" >/dev/null
              URL="$(jq -r '.outputs.repository_urls.value[0] // .outputs.repository_url.value // .outputs.ecr_repository_url.value // empty' "$TMP" || true)"
            fi
            [ -n "$URL" ] && [ "$URL" != "None" ] || { echo "::error::ECR repository URL not found for rollback flow"; exit 1; }
            echo "ECR_REPO_URL=$URL" | tee -a "$GITHUB_ENV" "$GITHUB_OUTPUT"
          fi

      - name: Log in to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Decide tag to deploy
        id: decide
        shell: bash
        run: |
          set -euo pipefail
          if [ -n "${{ github.event.inputs.ROLLBACK_TAG }}" ]; then
            TAG="${{ github.event.inputs.ROLLBACK_TAG }}"
          elif [ -n "${{ needs.build_image.outputs.build_tag }}" ]; then
            TAG="${{ needs.build_image.outputs.build_tag }}"
          else
            TAG="latest"
          fi
          echo "TAG_TO_DEPLOY=$TAG" | tee -a "$GITHUB_OUTPUT" >> "$GITHUB_ENV"
          echo "Deploying tag: $TAG"

      - name: Deploy containers via SSM (atomic, rollback, record last-good) + logs
        shell: bash
        run: |
          set -euo pipefail
          TAG="${{ steps.decide.outputs.TAG_TO_DEPLOY }}"
          ENV_NAME="${{ github.event.inputs.ENV }}"
          IMAGE_REPO="${{ env.ECR_REPO_URL }}"
          REGION="${{ env.AWS_REGION }}"
          INSTANCE="${{ env.INSTANCE_ID }}"

          if [ -z "$IMAGE_REPO" ]; then
            echo "::error::ECR_REPO_URL not set"; exit 1
          fi

          if [ ! -f docker/docker-compose.yml ]; then
            echo "::error::docker/docker-compose.yml not found in repo"
            exit 1
          fi
          COMPOSE_B64="$(base64 -w 0 docker/docker-compose.yml)"

          cat > ssm-deploy.json <<'JSON'
          {
            "commands": [
              "set -euo pipefail",
              "cd /home/ubuntu",

              "echo \"__COMPOSE_B64__\" | base64 -d > docker-compose.yml",
              "chown ubuntu:ubuntu docker-compose.yml || true",

              "ENV_NAME=__ENV_NAME__",
              "TAG=__TAG__",
              "IMAGE_REPO=__IMAGE_REPO__",
              "REGION=__REGION__",

              "PARAM=\"/idlms/shared/${ENV_NAME}/.env\"",
              "ENV_CONTENT=$(aws ssm get-parameter --name \"$PARAM\" --with-decryption --query \"Parameter.Value\" --output text --region ${REGION} 2>/dev/null || echo '')",
              "printf \"%s\" \"$ENV_CONTENT\" > .env",
              "grep -q '^IMAGE_REPO=' .env && sed -i 's|^IMAGE_REPO=.*|IMAGE_REPO='\"${IMAGE_REPO}\"'|' .env || echo \"IMAGE_REPO=${IMAGE_REPO}\" >> .env",
              "grep -q '^BUILD_TAG=' .env && sed -i 's|^BUILD_TAG=.*|BUILD_TAG='\"${TAG}\"'|' .env || echo \"BUILD_TAG=${TAG}\" >> .env",

              "if docker compose version >/dev/null 2>&1; then DC='docker compose'; elif command -v docker-compose >/dev/null 2>&1; then DC='docker-compose'; else curl -L \"https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose && chmod +x /usr/local/bin/docker-compose && ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose || true; DC='docker-compose'; fi",

              "ECR_HOST=${IMAGE_REPO%%/*}",
              "aws ecr get-login-password --region ${REGION} | docker login --username AWS --password-stdin ${ECR_HOST}",

              "deploy_tag() {",
              "  local tag=\"$1\"",
              "  sed -i 's|^BUILD_TAG=.*|BUILD_TAG='\"${tag}\"'|' .env || true",
              "  ${DC} --env-file .env pull --ignore-pull-failures || true",
              "  ${DC} --env-file .env up -d --force-recreate || true",
              "  sleep 25",
              "  CNT=$(docker ps --format '{{.Image}} {{.Status}}' | awk -v img=\"${IMAGE_REPO}:${tag}\" '$1==img && $2 ~ /^Up/ {c++} END{print c+0}')",
              "  if [ \"$CNT\" -ge 1 ]; then return 0; else return 1; fi",
              "}",

              "if deploy_tag \"${TAG}\"; then",
              "  aws ssm put-parameter --name \"/idlms/license-api/last-successful-build\" --value \"${TAG}\" --type String --overwrite --region ${REGION} || true",
              "  exit 0",
              "fi",

              "echo 'Deployment failed. Attempting rollback...' >&2",
              "PREV=$(aws ssm get-parameter --name \"/idlms/license-api/last-successful-build\" --query \"Parameter.Value\" --output text --region ${REGION} 2>/dev/null || echo '')",
              "if [ -n \"$PREV\" ] && [ \"$PREV\" != \"None\" ]; then",
              "  if deploy_tag \"$PREV\"; then echo \"Rollback succeeded to ${PREV}\"; exit 0; fi",
              "fi",

              "echo '------ diagnostics: docker ps -a ------'",
              "docker ps -a --format 'table {{.Names}}\\t{{.Image}}\\t{{.Status}}'",
              "for c in $(docker ps -a --format '{{.Names}}'); do echo \"========== logs: $c ==========\"; docker logs --tail 200 \"$c\" || true; done",
              "exit 1"
            ]
          }
          JSON

          sed -i "s|__ENV_NAME__|${ENV_NAME}|g" ssm-deploy.json
          sed -i "s|__TAG__|${TAG}|g" ssm-deploy.json
          sed -i "s|__IMAGE_REPO__|${IMAGE_REPO}|g" ssm-deploy.json
          sed -i "s|__REGION__|${REGION}|g" ssm-deploy.json
          sed -i "s|__COMPOSE_B64__|${COMPOSE_B64}|g" ssm-deploy.json

          CMD_ID="$(aws ssm send-command \
            --document-name 'AWS-RunShellScript' \
            --instance-ids "${INSTANCE}" \
            --comment "Deploy containers ${ENV_NAME} tag=${TAG}" \
            --parameters file://ssm-deploy.json \
            --query 'Command.CommandId' \
            --output text \
            --region "${REGION}")"

          # Poll and print logs
          while true; do
            STATUS="$(aws ssm list-command-invocations --command-id "$CMD_ID" --details --query 'CommandInvocations[0].Status' --output text --region "$REGION")"
            case "$STATUS" in Pending|InProgress|Delayed) sleep 5 ;; Success|Cancelled|TimedOut|Failed) break ;; *) sleep 5 ;; esac
          done
          echo "SSM status: $STATUS"
          echo "----- STDOUT -----"
          aws ssm get-command-invocation --command-id "$CMD_ID" --instance-id "$INSTANCE" --region "$REGION" --query 'StandardOutputContent' --output text || true
          echo "----- STDERR -----"
          aws ssm get-command-invocation --command-id "$CMD_ID" --instance-id "$INSTANCE" --region "$REGION" --query 'StandardErrorContent'  --output text || true
          [ "$STATUS" = "Success" ] || { echo "::error::deploy failed"; exit 1; }

  verify:
    name: Post-deploy health check
    runs-on: ubuntu-latest
    needs: deploy
    if: ${{ always() && (needs.build_image.result == 'success' || needs.build_image.result == 'skipped') }}
    environment: ${{ github.event.inputs.ENV }}
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Wait 30 seconds for containers to settle
        shell: bash
        run: sleep 30

      - name: Health check via SSM (match image:tag)
        shell: bash
        run: |
          set -euo pipefail
          ENV_INPUT="${{ github.event.inputs.ENV }}"
          REGION="${{ env.AWS_REGION }}"
          REPO="${{ needs.deploy.outputs.ecr_repo_url }}"
          TAG="${{ needs.deploy.outputs.tag_to_deploy }}"

          if [ -z "$REPO" ] || [ -z "$TAG" ]; then
            echo "::error::Missing repo/tag from deploy outputs"; exit 1
          fi

          INSTANCE_ID="$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=Backend API IDLMS-${ENV_INPUT}" "Name=instance-state-name,Values=running" \
            --query "sort_by(Reservations[].Instances[], &LaunchTime)[-1].InstanceId" \
            --region "$REGION" --output text || true)"
          if [ -z "$INSTANCE_ID" ] || [ "$INSTANCE_ID" = "None" ]; then
            INSTANCE_ID="$(aws ec2 describe-instances \
              --filters "Name=tag:Name,Values=${ENV_INPUT}-idlms-app" "Name=instance-state-name,Values=running" \
              --query "sort_by(Reservations[].Instances[], &LaunchTime)[-1].InstanceId" \
              --region "$REGION" --output text || true)"
          fi
          if [ -z "$INSTANCE_ID" ] || [ "$INSTANCE_ID" = "None" ]; then
            echo "::error::pods not up"; exit 1
          fi

          cat > ssm-check.json <<'JSON'
          {
            "commands": [
              "set -euo pipefail",
              "REPO='__REPO__'",
              "TAG='__TAG__'",
              "CNT=$(docker ps --format '{{.Image}} {{.Status}}' | awk -v img=\"${REPO}:${TAG}\" '$1==img && $2 ~ /^Up/ {c++} END{print c+0}')",
              "if [ \"$CNT\" -ge 1 ]; then echo 'pods up'; exit 0; fi",
              "echo 'pods not up';",
              "docker ps -a --format 'table {{.Names}}\\t{{.Image}}\\t{{.Status}}'",
              "exit 1"
            ]
          }
          JSON
          sed -i "s|__REPO__|${REPO}|g" ssm-check.json
          sed -i "s|__TAG__|${TAG}|g" ssm-check.json

          CMD_ID="$(aws ssm send-command \
            --document-name 'AWS-RunShellScript' \
            --instance-ids "$INSTANCE_ID" \
            --comment 'Post-deploy health check' \
            --parameters file://ssm-check.json \
            --query 'Command.CommandId' \
            --output text \
            --region "$REGION")"

          while true; do
            STATUS="$(aws ssm list-command-invocations --command-id "$CMD_ID" --details --query 'CommandInvocations[0].Status' --output text --region "$REGION")"
            case "$STATUS" in Pending|InProgress|Delayed) sleep 5 ;; Success|Cancelled|TimedOut|Failed) break ;; *) sleep 5 ;; esac
          done
          echo "SSM status: $STATUS"
          aws ssm get-command-invocation --command-id "$CMD_ID" --instance-id "$INSTANCE_ID" --region "$REGION" --query 'StandardOutputContent' --output text || true
          [ "$STATUS" = "Success" ] || { echo "::error::pods not up"; exit 1; }
