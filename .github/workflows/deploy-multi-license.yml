name: Deploy Multi License API (reuse platform-main)

on:
  workflow_dispatch:
    inputs:
      ENV:
        description: "Environment to deploy (dev/stage/prod)"
        required: true
        default: "stage"
      ROLLBACK_TAG:
        description: "If set (latest or 2025.06.30.002), deploy that tag without building"
        required: false
      GIT_REF:
        description: "Git ref/branch to use for code & TF"
        required: false
        default: "main"

env:
  AWS_REGION: ${{ vars.AWS_REGION }}

permissions:
  id-token: write
  contents: read

concurrency:
  group: deploy-single-${{ github.event.inputs.ENV }}
  cancel-in-progress: false

jobs:
  # ───────────── Build Image (only when no rollback tag) ─────────────
  build_image:
    if: ${{ !github.event.inputs.ROLLBACK_TAG }}
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.ENV || 'stage' }}
    outputs:
      BUILD_TAG: ${{ steps.tags.outputs.BUILD_TAG }}
      IMAGE_URI: ${{ steps.tags.outputs.IMAGE_URI }}
      LATEST_URI: ${{ steps.tags.outputs.LATEST_URI }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.GIT_REF }}

      - name: Guard AWS_REGION
        run: |
          if [ -z "${{ env.AWS_REGION }}" ]; then
            echo "::error::AWS_REGION is empty. Define repo/env variable AWS_REGION or set a default."
            exit 1
          fi

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Log in to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Generate build tags
        id: tags
        run: |
          if [ -z "${{ env.AWS_REGION }}" ]; then exit 1; fi
          # Get ECR repo URL from platform later; for now we will set after consume_infra (deploy job)
          # Build tag (DATE + run number)
          DATE_TAG=$(date +'%Y.%m.%d')
          BUILD_NUM=$(printf "%03d" $GITHUB_RUN_NUMBER)
          BUILD_TAG="${DATE_TAG}.${BUILD_NUM}"
          echo "BUILD_TAG=$BUILD_TAG"    | tee -a "$GITHUB_ENV" >> "$GITHUB_OUTPUT"

      - name: Build image (temporary local tag)
        run: |
          docker build -t idlms-tmp:${{ env.BUILD_TAG }} -f docker/Dockerfile src

  # ───────────── Read platform-main outputs (ECR URL, instance id, bucket) ─────────────
  consume_infra:
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.ENV || 'stage' }}
    outputs:
      ECR_REPO_URL: ${{ steps.platform.outputs.ECR_REPO_URL }}
      TARGET_INSTANCE_ID: ${{ steps.platform.outputs.TARGET_INSTANCE_ID }}
      BACKUP_BUCKET: ${{ steps.acct.outputs.BACKUP_BUCKET }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.GIT_REF }}

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_wrapper: false

      - name: Read platform-main remote outputs
        id: platform
        run: |
          set -euo pipefail
          cd infra/platform-remote
          terraform init -input=false -no-color -upgrade
          terraform apply -refresh-only -auto-approve -input=false -no-color -var-file="${{ github.event.inputs.ENV }}.tfvars"
          terraform output -json > /tmp/platform_remote.json
          cat /tmp/platform_remote.json | jq

          ECR_REPO_URL=$(jq -r '.ecr_repository_url.value // empty' /tmp/platform_remote.json)
          TARGET_INSTANCE_ID=$(jq -r '.compute_instance_id.value // empty' /tmp/platform_remote.json)

          echo "ECR_REPO_URL=$ECR_REPO_URL" >> "$GITHUB_ENV"
          echo "TARGET_INSTANCE_ID=$TARGET_INSTANCE_ID" >> "$GITHUB_ENV"
          echo "ECR_REPO_URL=$ECR_REPO_URL" >> "$GITHUB_OUTPUT"
          echo "TARGET_INSTANCE_ID=$TARGET_INSTANCE_ID" >> "$GITHUB_OUTPUT"

      - name: Compute account id & artifact bucket
        id: acct
        run: |
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          BACKUP_BUCKET="idlms-${{ github.event.inputs.ENV }}-built-artifact-${ACCOUNT_ID}"
          echo "BACKUP_BUCKET=$BACKUP_BUCKET" >> "$GITHUB_ENV"
          echo "BACKUP_BUCKET=$BACKUP_BUCKET" >> "$GITHUB_OUTPUT"

  # ───────────── Deploy (uses image + infra outputs) ─────────────
  deploy:
    runs-on: ubuntu-latest
    needs: [build_image, consume_infra]
    environment: ${{ github.event.inputs.ENV || 'stage' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.GIT_REF }}

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Show resolved values (sanity)
        run: |
          echo "ENV=${{ github.event.inputs.ENV }}"
          echo "ECR_REPO_URL=${{ needs.consume_infra.outputs.ECR_REPO_URL }}"
          echo "TARGET_INSTANCE_ID=${{ needs.consume_infra.outputs.TARGET_INSTANCE_ID }}"
          echo "BACKUP_BUCKET=${{ needs.consume_infra.outputs.BACKUP_BUCKET }}"
          echo "BUILD_TAG=${{ needs.build_image.outputs.BUILD_TAG || 'latest' }}"

      # NOTE: to keep this first run simple and error-free, we only upload docker-compose.yml
      # and DO NOT run the long SSM deployment step yet.
      - name: Upload docker-compose.yml to S3
        run: |
          aws s3 cp docker/docker-compose.yml "s3://${{ needs.consume_infra.outputs.BACKUP_BUCKET }}/${{ github.event.inputs.ENV }}/docker-compose.yml"
