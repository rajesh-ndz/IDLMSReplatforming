name: Deploy Multi License API with Rollback Options

on:
  workflow_dispatch:
    inputs:
      ENV:
        description: 'Environment to deploy (dev/staging/prod)'
        required: true
        default: "stage"
      ROLLBACK_TAG:
        description: 'Optional: Previous build tag (e.g., 2025.06.30.02). If left blank, deploys latest.'
        required: false

env:
  AWS_REGION: ${{ vars.AWS_REGION }}

concurrency:
  group: deploy-${{ github.ref_name }}-${{ github.event.inputs.ENV || 'stage' }}
  cancel-in-progress: false

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.ENV || 'stage' }}
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout feature/btl-77
        uses: actions/checkout@v4
        with:
          ref: feature/btl-77

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.5.0

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v3
        with:
          aws-access-key-id:     ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region:            ${{ env.AWS_REGION }}

      - name: Get AWS Account ID & set backup bucket
        id: acct
        run: |
          set -euo pipefail
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          echo "ACCOUNT_ID=$ACCOUNT_ID" >> "$GITHUB_ENV"
          echo "BACKUP_BUCKET=idlms-${{ github.event.inputs.ENV }}-built-artifact-${ACCOUNT_ID}" >> "$GITHUB_ENV"

      - name: Terraform apply reuse stacks (read-only)
        run: |
          set -euo pipefail
          ROOT="infra/environments/stage/stacks"
          NLB_EXPECTED="backend.tf providers.tf main.tf outputs.tf"
          ECR_EXPECTED="backend.tf providers.tf variables.tf main.tf outputs.tf"

          for s in network-reuse compute-reuse nlb-reuse ecr-reuse s3-reuse restapi-reuse cloudwatch-reuse ssm-reuse; do
            echo "=== $s ==="

            # Keep only expected files for nlb-reuse (avoid stray files from previous attempts)
            if [ "$s" = "nlb-reuse" ]; then
              if ls "$ROOT/$s"/*.tf >/dev/null 2>&1; then
                for f in "$ROOT/$s"/*.tf; do
                  base=$(basename "$f")
                  case " $NLB_EXPECTED " in *" $base "*) : ;; *) echo "Removing unexpected (nlb-reuse): $base"; rm -f "$f" ;; esac
                done
              fi
            fi

            # Keep only expected files for ecr-reuse (avoid duplicates/provider tf)
            if [ "$s" = "ecr-reuse" ]; then
              rm -rf "$ROOT/$s/infra" || true
              if ls "$ROOT/$s"/*.tf >/dev/null 2>&1; then
                for f in "$ROOT/$s"/*.tf; do
                  base=$(basename "$f")
                  case " $ECR_EXPECTED " in *" $base "*) : ;; *) echo "Removing unexpected (ecr-reuse): $base"; rm -f "$f" ;; esac
                done
              fi
            fi

            terraform -chdir="$ROOT/$s" init -upgrade
            terraform -chdir="$ROOT/$s" validate -no-color
            terraform -chdir="$ROOT/$s" plan -no-color -out=tfplan
            terraform -chdir="$ROOT/$s" apply -auto-approve tfplan
            rm -f "$ROOT/$s/tfplan"
          done

      - name: Read ECR repository URL from ecr-reuse outputs
        id: ecr
        run: |
          set -euo pipefail
          OUT_JSON=$(terraform -chdir=infra/environments/stage/stacks/ecr-reuse output -json repository_urls || true)
          if [ -z "$OUT_JSON" ] || [ "$OUT_JSON" = "null" ]; then
            echo "::error::No 'repository_urls' output found in ecr-reuse"
            terraform -chdir=infra/environments/stage/stacks/ecr-reuse output || true
            exit 1
          fi
          ECR_REPO_URL=$(echo "$OUT_JSON" | jq -r 'if type=="array" then .[0] else . end')
          if [ -z "$ECR_REPO_URL" ] || [ "$ECR_REPO_URL" = "null" ]; then
            echo "::error::ECR_REPO_URL is empty"; exit 1
          fi
          echo "ECR_REPO_URL=$ECR_REPO_URL" >> "$GITHUB_ENV"
          echo "Using ECR: $ECR_REPO_URL"

      - name: Upload docker-compose.yml to S3
        run: |
          set -euo pipefail
          echo "Uploading to bucket: $BACKUP_BUCKET"
          aws s3 cp docker/docker-compose.yml "s3://$BACKUP_BUCKET/${{ github.event.inputs.ENV }}/docker-compose.yml"

      - name: Log in to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Generate build tags
        id: tags
        run: |
          set -euo pipefail
          DATE_TAG=$(date +'%Y.%m.%d')
          BUILD_NUM=$(printf "%03d" "$GITHUB_RUN_NUMBER")
          BUILD_TAG="${DATE_TAG}.${BUILD_NUM}"
          IMAGE_URI="${{ env.ECR_REPO_URL }}:${BUILD_TAG}"
          LATEST_URI="${{ env.ECR_REPO_URL }}:latest"
          echo "BUILD_TAG=$BUILD_TAG" >> "$GITHUB_ENV"
          echo "IMAGE_URI=$IMAGE_URI" >> "$GITHUB_ENV"
          echo "LATEST_URI=$LATEST_URI" >> "$GITHUB_ENV"

      - name: Build and tag Docker image
        run: docker build -t "$IMAGE_URI" -t "$LATEST_URI" -f docker/Dockerfile src

      - name: Push Docker images to ECR
        run: |
          set -euo pipefail
          docker push "$IMAGE_URI"
          docker push "$LATEST_URI"

      - name: Determine tag to deploy (supports rollback)
        id: determine-tag
        run: |
          set -euo pipefail
          if [ -n "${{ github.event.inputs.ROLLBACK_TAG }}" ]; then
            TAG_TO_DEPLOY="${{ github.event.inputs.ROLLBACK_TAG }}"
          else
            TAG_TO_DEPLOY="${{ env.BUILD_TAG }}"
          fi
          echo "TAG_TO_DEPLOY=$TAG_TO_DEPLOY" >> "$GITHUB_ENV"
          echo "Deploying tag: $TAG_TO_DEPLOY"

      - name: Terraform apply reuse stacks (read-only)
        run: |
          set -euo pipefail
          ROOT="infra/environments/stage/stacks"
          NLB_EXPECTED="backend.tf providers.tf main.tf outputs.tf"
          ECR_EXPECTED="backend.tf providers.tf variables.tf main.tf outputs.tf"

          for s in network-reuse compute-reuse nlb-reuse ecr-reuse s3-reuse restapi-reuse cloudwatch-reuse ssm-reuse; do
            echo "=== $s ==="

            if [ "$s" = "nlb-reuse" ]; then
              echo "--- NLB BEFORE cleanup ---"
              ls -la "$ROOT/$s" || true
              (grep -RInE '\bcheck\b|precondition|postcondition' "$ROOT/$s" && echo "::warning::Found check/pre/postcondition in nlb-reuse") || true
              if ls "$ROOT/$s"/*.tf >/dev/null 2>&1; then
                for f in "$ROOT/$s"/*.tf; do
                  base=$(basename "$f")
                  case " $NLB_EXPECTED " in *" $base "*) : ;; *) echo "Removing unexpected (nlb-reuse): $base"; rm -f "$f" ;; esac
                done
              fi
              echo "--- NLB AFTER cleanup ---"
              ls -la "$ROOT/$s" || true
              for f in $NLB_EXPECTED; do echo "----- $f -----"; sed -n '1,200p' "$ROOT/$s/$f" || true; done
            fi

            if [ "$s" = "ecr-reuse" ]; then
              echo "--- ECR BEFORE cleanup ---"
              ls -la "$ROOT/$s" || true
              # kill accidental nested dir or old garbage from earlier attempts
              rm -rf "$ROOT/$s/infra" || true
              # keep only the five expected files
              if ls "$ROOT/$s"/*.tf >/dev/null 2>&1; then
                for f in "$ROOT/$s"/*.tf; do
                  base=$(basename "$f")
                  case " $ECR_EXPECTED " in *" $base "*) : ;; *) echo "Removing unexpected (ecr-reuse): $base"; rm -f "$f" ;; esac
                done
              fi
              # show contents and verify no 'check' anywhere
              echo "--- ECR AFTER cleanup ---"
              ls -la "$ROOT/$s" || true
              echo "--- grep for check/pre/postcondition (should be empty) ---"
              (grep -RInE '\bcheck\b|precondition|postcondition' "$ROOT/$s" && echo "::warning::Found check/pre/postcondition in ecr-reuse") || true
              for f in $ECR_EXPECTED; do echo "----- $f -----"; sed -n '1,200p' "$ROOT/$s/$f" || true; done
            fi

            terraform -chdir="$ROOT/$s" init -upgrade
            terraform -chdir="$ROOT/$s" validate -no-color
            terraform -chdir="$ROOT/$s" plan -no-color -out=tfplan
            terraform -chdir="$ROOT/$s" apply -auto-approve tfplan
            rm -f "$ROOT/$s/tfplan"
          done
