name: Deploy Multi License API with Rollback (reuse platform-main)

on:
  workflow_dispatch:
    inputs:
      ENV:
        description: "Environment to deploy (dev/stage/prod)"
        required: true
        default: "stage"
      ROLLBACK_TAG:
        description: "Tag to deploy without building (e.g., 2025.06.30.002 or latest)"
        required: false
      GIT_REF:
        description: "Git ref/branch to build"
        required: false
        default: "main"
      APP_PORT:
        description: "Container port"
        required: true
        default: "4000"
      HOST_PORT:
        description: "EC2 host port"
        required: true
        default: "4000"

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: ap-south-1
  # platform-main state bucket (per ENV)
  PLATFORM_STATE_BUCKET_STAGE: stage-btl-idlms-repo-backend-api-tfstate-592776312448
  PLATFORM_STATE_BUCKET_DEV:   dev-btl-idlms-repo-backend-api-tfstate-592776312448
  PLATFORM_STATE_BUCKET_PROD:  prod-btl-idlms-repo-backend-api-tfstate-592776312448

jobs:
  build_and_push:
    if: ${{ !github.event.inputs.ROLLBACK_TAG }}
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.ENV }}
    outputs:
      BUILD_TAG: ${{ steps.tags.outputs.BUILD_TAG }}
      ECR_REPO_URL: ${{ steps.ecr.outputs.ECR_REPO_URL }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.GIT_REF }}

      - name: Configure AWS (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Determine platform-main state bucket for ENV
        id: bucket
        run: |
          case "${{ github.event.inputs.ENV }}" in
            dev)   echo "B=${{ env.PLATFORM_STATE_BUCKET_DEV }}"   >> $GITHUB_ENV ;;
            stage) echo "B=${{ env.PLATFORM_STATE_BUCKET_STAGE }}" >> $GITHUB_ENV ;;
            prod)  echo "B=${{ env.PLATFORM_STATE_BUCKET_PROD }}"  >> $GITHUB_ENV ;;
            *)     echo "::error::Unknown ENV"; exit 1 ;;
          esac
          LOC=$(aws s3api get-bucket-location --bucket "$B" --query 'LocationConstraint' --output text || true)
          [ "$LOC" = "None" ] && LOC="us-east-1"
          [ -z "$LOC" ] || [ "$LOC" = "null" ] && { echo "::error::Platform bucket region not found"; exit 1; }
          echo "PLATFORM_STATE_REGION=$LOC" >> $GITHUB_ENV

      - name: Read ECR repository URL from platform-main ECR tfstate
        id: ecr
        run: |
          KEY="${{ github.event.inputs.ENV }}/ecr/terraform.tfstate"
          aws s3 cp "s3://$B/$KEY" /tmp/ecr.tfstate --region "$PLATFORM_STATE_REGION" --no-progress
          # platform-main outputs: repository_urls is an array; take index 0
          URL=$(jq -r '.outputs.repository_urls.value[0] // empty' /tmp/ecr.tfstate)
          [ -z "$URL" ] && { echo "::error::ECR repo URL not found in platform-main state"; exit 1; }
          echo "ECR_REPO_URL=$URL" | tee -a $GITHUB_ENV >> $GITHUB_OUTPUT

      - name: Login to ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Generate build tag
        id: tags
        run: |
          DATE_TAG="$(date -u +'%Y.%m.%d')"
          BUILD_NUM="$(printf "%03d" "$GITHUB_RUN_NUMBER")"
          BUILD_TAG="${DATE_TAG}.${BUILD_NUM}"
          echo "BUILD_TAG=$BUILD_TAG" | tee -a $GITHUB_ENV >> $GITHUB_OUTPUT

      - name: Build and push image
        run: |
          IMAGE_URI="${ECR_REPO_URL}:${BUILD_TAG}"
          LATEST_URI="${ECR_REPO_URL}:latest"
          docker build -t "$IMAGE_URI" -t "$LATEST_URI" .
          docker push "$IMAGE_URI"
          docker push "$LATEST_URI"

  deploy:
    runs-on: ubuntu-latest
    needs: [build_and_push]
    environment: ${{ github.event.inputs.ENV }}
    outputs:
      TAG_TO_DEPLOY: ${{ steps.decide.outputs.TAG_TO_DEPLOY }}
      ECR_REPO_URL:  ${{ steps.prepare.outputs.ECR_REPO_URL }}

    steps:
      - name: Configure AWS (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Determine platform-main state bucket for ENV
        id: bucket
        run: |
          case "${{ github.event.inputs.ENV }}" in
            dev)   echo "B=${{ env.PLATFORM_STATE_BUCKET_DEV }}"   >> $GITHUB_ENV ;;
            stage) echo "B=${{ env.PLATFORM_STATE_BUCKET_STAGE }}" >> $GITHUB_ENV ;;
            prod)  echo "B=${{ env.PLATFORM_STATE_BUCKET_PROD }}"  >> $GITHUB_ENV ;;
            *)     echo "::error::Unknown ENV"; exit 1 ;;
          esac
          LOC=$(aws s3api get-bucket-location --bucket "$B" --query 'LocationConstraint' --output text || true)
          [ "$LOC" = "None" ] && LOC="us-east-1"
          [ -z "$LOC" ] || [ "$LOC" = "null" ] && { echo "::error::Platform bucket region not found"; exit 1; }
          echo "PLATFORM_STATE_REGION=$LOC" >> $GITHUB_ENV

      - name: Read INSTANCE_ID + ECR repo URL from platform-main tfstate
        id: prepare
        run: |
          # instance id
          aws s3 cp "s3://$B/${{ github.event.inputs.ENV }}/compute/terraform.tfstate" /tmp/compute.tfstate --region "$PLATFORM_STATE_REGION" --no-progress
          INSTANCE_ID=$(jq -r '.outputs.instance_id.value // empty' /tmp/compute.tfstate)
          [ -z "$INSTANCE_ID" ] && { echo "::error::instance_id not found"; exit 1; }
          echo "INSTANCE_ID=$INSTANCE_ID" >> $GITHUB_ENV
          # ecr repo url
          aws s3 cp "s3://$B/${{ github.event.inputs.ENV }}/ecr/terraform.tfstate" /tmp/ecr.tfstate --region "$PLATFORM_STATE_REGION" --no-progress
          URL=$(jq -r '.outputs.repository_urls.value[0] // empty' /tmp/ecr.tfstate)
          [ -z "$URL" ] && { echo "::error::ECR repo URL not found"; exit 1; }
          echo "ECR_REPO_URL=$URL" | tee -a $GITHUB_ENV >> $GITHUB_OUTPUT

      - name: Decide tag to deploy (build tag / rollback / latest)
        id: decide
        run: |
          if [ -n "${{ github.event.inputs.ROLLBACK_TAG }}" ]; then
            TAG="${{ github.event.inputs.ROLLBACK_TAG }}"
          elif [ -n "${{ needs.build_and_push.outputs.BUILD_TAG }}" ]; then
            TAG="${{ needs.build_and_push.outputs.BUILD_TAG }}"
          else
            TAG="latest"
          fi
          echo "TAG_TO_DEPLOY=$TAG" | tee -a $GITHUB_ENV >> $GITHUB_OUTPUT
          echo "Deploying tag: $TAG on repo: ${ECR_REPO_URL}"

      - name: SSM deploy (docker pull + run) with rollback
        run: |
          CMD_ID=$(aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters commands="[
              \"set -euo pipefail\",
              \"sudo apt-get update -y && sudo apt-get install -y docker.io jq || true\",
              \"sudo systemctl enable docker || true\",
              \"sudo systemctl start docker || true\",
              \"APP_NAME=idlms-app\",
              \"IMAGE=${ECR_REPO_URL}:${TAG_TO_DEPLOY}\",
              \"ECR_HOST=${ECR_REPO_URL%%/*}\",
              \"aws ecr get-login-password --region ${AWS_REGION} | sudo docker login --username AWS --password-stdin ${ECR_HOST}\",
              \"echo 'Pulling image: '$IMAGE\",
              \"sudo docker pull $IMAGE\",
              \"echo 'Stopping old container (if any)...'\",
              \"sudo docker rm -f $APP_NAME || true\",
              \"echo 'Starting container...'\",
              \"sudo docker run -d --name $APP_NAME --restart unless-stopped -p ${{ github.event.inputs.HOST_PORT }}:${{ github.event.inputs.APP_PORT }} $IMAGE\",
              \"sleep 10\",
              \"RUNNING=$(sudo docker ps --format '{{.Names}} {{.Status}}' | awk '\\$1==\\\"'\"$APP_NAME\"'\\\" && /Up/ {print \\$0}')\",
              \"if [ -n \\\"$RUNNING\\\" ]; then echo 'Container up:' \\\"$RUNNING\\\"; aws ssm put-parameter --name /idlms/license-api/last-successful-build --type String --overwrite --value ${TAG_TO_DEPLOY} --region ${AWS_REGION}; exit 0; fi\",
              \"echo 'Primary deploy failed, attempting rollback...' >&2\",
              \"PREV=$(aws ssm get-parameter --name /idlms/license-api/last-successful-build --query Parameter.Value --output text --region ${AWS_REGION} 2>/dev/null || echo '')\",
              \"if [ -n \\\"$PREV\\\" ] && [ \\\"$PREV\\\" != \\\"None\\\" ]; then\",
              \"  IMAGE=${ECR_REPO_URL}:$PREV\",
              \"  sudo docker pull $IMAGE || true\",
              \"  sudo docker rm -f $APP_NAME || true\",
              \"  sudo docker run -d --name $APP_NAME --restart unless-stopped -p ${{ github.event.inputs.HOST_PORT }}:${{ github.event.inputs.APP_PORT }} $IMAGE || true\",
              \"  sleep 10\",
              \"  RUNNING=$(sudo docker ps --format '{{.Names}} {{.Status}}' | awk '\\$1==\\\"'\"$APP_NAME\"'\\\" && /Up/ {print \\$0}')\",
              \"  [ -n \\\"$RUNNING\\\" ] && { echo 'Rollback succeeded to' $PREV; exit 0; } || true\",
              \"fi\",
              \"echo 'Deployment failed and rollback failed.' >&2\",
              \"sudo docker ps -a --format 'table {{.Names}}\\t{{.Image}}\\t{{.Status}}' || true\",
              \"exit 1\"
            ]" \
            --query "Command.CommandId" --output text)
          aws ssm wait command-executed --command-id "$CMD_ID" --instance-id "$INSTANCE_ID"
          aws ssm get-command-invocation --command-id "$CMD_ID" --instance-id "$INSTANCE_ID"

  verify:
    runs-on: ubuntu-latest
    needs: deploy
    environment: ${{ github.event.inputs.ENV }}
    steps:
      - name: Configure AWS (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Check container is up via SSM (docker ps)
        run: |
          # Read last instance id again (same as deploy)
          case "${{ github.event.inputs.ENV }}" in
            dev)   B="${{ env.PLATFORM_STATE_BUCKET_DEV }}"   ;;
            stage) B="${{ env.PLATFORM_STATE_BUCKET_STAGE }}" ;;
            prod)  B="${{ env.PLATFORM_STATE_BUCKET_PROD }}"  ;;
          esac
          LOC=$(aws s3api get-bucket-location --bucket "$B" --query 'LocationConstraint' --output text || true)
          [ "$LOC" = "None" ] && LOC="us-east-1"
          aws s3 cp "s3://$B/${{ github.event.inputs.ENV }}/compute/terraform.tfstate" /tmp/compute.tfstate --region "$LOC" --no-progress
          INSTANCE_ID=$(jq -r '.outputs.instance_id.value // empty' /tmp/compute.tfstate)

          CMD_ID=$(aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters commands="[\"docker ps --format '{{.Names}}: {{.Image}} {{.Status}} {{.Ports}}'\"]" \
            --query "Command.CommandId" --output text)
          aws ssm wait command-executed --command-id "$CMD_ID" --instance-id "$INSTANCE_ID"
          aws ssm get-command-invocation --command-id "$CMD_ID" --instance-id "$INSTANCE_ID"
