name: Deploy Multi License API (IDLMS)

on:
  workflow_dispatch:
    inputs:
      ENV:
        description: "Environment (dev/stage/prod)"
        required: true
        default: "stage"
      ROLLBACK_TAG:
        description: "Optional: deploy this previous image tag instead of building new"
        required: false

permissions:
  contents: read
  id-token: write

concurrency:
  group: deploy-${{ github.event.inputs.ENV }}
  cancel-in-progress: false

env:
  AWS_REGION: ${{ vars.AWS_REGION }}

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.ref }}

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.7
          terraform_wrapper: false   # important

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Ensure default region if not set
        run: |
          if [ -z "${AWS_REGION:-}" ]; then
            echo "AWS_REGION=ap-south-1" >> "$GITHUB_ENV"
          fi

      - name: Configure AWS Credentials (static keys)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region:            ${{ env.AWS_REGION }}
          aws-access-key-id:     ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      - name: Discover account & set artifact bucket
        id: acct
        run: |
          set -euo pipefail
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          echo "ACCOUNT_ID=$ACCOUNT_ID" >> "$GITHUB_ENV"
          echo "BACKUP_BUCKET=idlms-${{ github.event.inputs.ENV }}-built-artifact-$ACCOUNT_ID" >> "$GITHUB_ENV"

      - name: Refresh reuse stacks (no-change apply)
        run: |
          set -euo pipefail
          ROOT="infra/environments/${{ github.event.inputs.ENV }}/stacks"
          for s in network-reuse compute-reuse nlb-reuse ecr-reuse; do
            if [ -d "$ROOT/$s" ]; then
              echo "== $s =="
              terraform -chdir="$ROOT/$s" init -reconfigure -input=false
              terraform -chdir="$ROOT/$s" validate -no-color || true
              terraform -chdir="$ROOT/$s" plan -refresh-only -no-color -out=tfplan || true
              terraform -chdir="$ROOT/$s" apply -refresh-only -auto-approve tfplan || true
              rm -f "$ROOT/$s/tfplan" || true
            else
              echo "skip: $ROOT/$s not present"
            fi
          done

      - name: Read Instance ID from compute-reuse
        run: |
          set -euo pipefail
          INSTANCE_ID=$(terraform -chdir=infra/environments/${{ github.event.inputs.ENV }}/stacks/compute-reuse output -raw instance_id)
          test -n "$INSTANCE_ID"
          echo "INSTANCE_ID=$INSTANCE_ID" >> "$GITHUB_ENV"
          echo "Using INSTANCE_ID=$INSTANCE_ID"

      - name: Read ECR repository URL
        run: |
          set -euo pipefail
          OUT_JSON=$(terraform -chdir=infra/environments/${{ github.event.inputs.ENV }}/stacks/ecr-reuse output -json repository_urls)
          ECR_REPO_URL=$(jq -r 'if type=="array" then .[0] else . end' <<<"$OUT_JSON")
          test -n "$ECR_REPO_URL" && [ "$ECR_REPO_URL" != "null" ] || { echo "::error::No ECR repo URL in ecr-reuse outputs"; exit 1; }
          echo "ECR_REPO_URL=$ECR_REPO_URL" >> "$GITHUB_ENV"
          echo "Using ECR: $ECR_REPO_URL"

      - name: Upload docker-compose.yml to S3
        run: aws s3 cp docker/docker-compose.yml "s3://$BACKUP_BUCKET/${{ github.event.inputs.ENV }}/docker-compose.yml"

      - name: Log in to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Generate build tags
        run: |
          DATE_TAG=$(date +'%Y.%m.%d')
          BUILD_NUM=$(printf "%03d" "$GITHUB_RUN_NUMBER")
          BUILD_TAG="${DATE_TAG}.${BUILD_NUM}"
          echo "BUILD_TAG=$BUILD_TAG" >> "$GITHUB_ENV"
          echo "IMAGE_URI=${ECR_REPO_URL}:${BUILD_TAG}" >> "$GITHUB_ENV"
          echo "LATEST_URI=${ECR_REPO_URL}:latest" >> "$GITHUB_ENV"

      - name: Build image
        run: docker build -t "$IMAGE_URI" -t "$LATEST_URI" -f docker/Dockerfile src

      - name: Push images
        run: |
          docker push "$IMAGE_URI"
          docker push "$LATEST_URI"

      - name: Decide tag to deploy (supports rollback)
        run: |
          if [ -n "${{ github.event.inputs.ROLLBACK_TAG }}" ]; then
            echo "TAG_TO_DEPLOY=${{ github.event.inputs.ROLLBACK_TAG }}" >> "$GITHUB_ENV"
          else
            echo "TAG_TO_DEPLOY=${BUILD_TAG}" >> "$GITHUB_ENV"
          fi

      - name: Deploy to EC2 via SSM
        env:
          ENV:           ${{ github.event.inputs.ENV }}
          AWS_REGION:    ${{ env.AWS_REGION }}
          ECR_REPO_URL:  ${{ env.ECR_REPO_URL }}
          TAG_TO_DEPLOY: ${{ env.TAG_TO_DEPLOY }}
          BACKUP_BUCKET: ${{ env.BACKUP_BUCKET }}
          INSTANCE_ID:   ${{ env.INSTANCE_ID }}
        run: |
          set -euo pipefail

          # Use INSTANCE_ID from compute-reuse output
          test -n "${INSTANCE_ID:-}" || { echo "::error::INSTANCE_ID missing"; exit 1; }

          # Build remote script template to file (safe under set -e)
          cat > /tmp/remote.sh <<'EOS'
          set -e
          cd /home/ubuntu

          ENV_NAME="__ENV__"
          ECR_REPO_URL="__ECR__"
          TAG_TO_DEPLOY="__TAG__"
          AWS_REGION="__REGION__"
          BACKUP_BUCKET="__BUCKET__"

          # Pull .env from SSM (optional but recommended)
          if aws ssm get-parameter --name "/idlms/shared/${ENV_NAME}/.env" --with-decryption >/dev/null 2>&1; then
            ENV_CONTENT=$(aws ssm get-parameter --name "/idlms/shared/${ENV_NAME}/.env" --with-decryption --query "Parameter.Value" --output text)
          else
            ENV_CONTENT="# placeholder env"
          fi
          printf "%s\n" "$ENV_CONTENT" > .env
          echo "BUILD_TAG=${TAG_TO_DEPLOY}" >> .env
          echo "IMAGE_REPO=${ECR_REPO_URL}" >> .env

          # Compose file from S3
          aws s3 cp "s3://${BACKUP_BUCKET}/${ENV_NAME}/docker-compose.yml" docker-compose.yml

          # Docker bits
          if ! command -v docker >/dev/null 2>&1; then
            sudo apt-get update -y && sudo apt-get install -y docker.io
          fi
          if ! command -v docker-compose >/dev/null 2>&1; then
            URL="https://github.com/docker/compose/releases/download/v2.28.1/docker-compose-$(uname -s)-$(uname -m)"
            sudo curl -L "$URL" -o /usr/local/bin/docker-compose
            sudo chmod +x /usr/local/bin/docker-compose
          fi
          aws ecr get-login-password --region "${AWS_REGION}" | docker login --username AWS --password-stdin "${ECR_REPO_URL%/*}"

          CURRENT_IMG="${ECR_REPO_URL}:${TAG_TO_DEPLOY}"

          # Fresh start
          docker-compose --env-file .env down || true
          docker rmi "${CURRENT_IMG}" || true
          docker-compose --env-file .env pull --ignore-pull-failures
          docker-compose --env-file .env up -d --force-recreate

          # Health check: expect 3 containers (api1, api2, api3)
          sleep 60
          RUNNING_CONTAINERS=$(docker ps --format '{{.Names}}' | grep -E "api1|api2|api3" | wc -l)
          if [ "$RUNNING_CONTAINERS" -ne 3 ]; then
            echo "Deployment failed. Rolling back..."
            PREV_TAG=$(aws ssm get-parameter --name "/idlms/license-api/${ENV_NAME}/last-successful-build" --query "Parameter.Value" --output text || echo "")
            if [ -z "$PREV_TAG" ]; then
              echo "No last-successful-build found; leaving services down for safety."
              exit 1
            fi
            sed -i "/^BUILD_TAG=/d" .env
            echo "BUILD_TAG=$PREV_TAG" >> .env
            PREV_IMG="${ECR_REPO_URL}:${PREV_TAG}"
            docker-compose --env-file .env down || true
            docker rmi "${CURRENT_IMG}" || true
            docker-compose --env-file .env pull --ignore-pull-failures
            docker-compose --env-file .env up -d --force-recreate
          else
            echo "All containers are up. Saving ${TAG_TO_DEPLOY} as last-successful-build..."
            aws ssm put-parameter --name "/idlms/license-api/${ENV_NAME}/last-successful-build" --value "${TAG_TO_DEPLOY}" --type String --overwrite
          fi
          EOS

          # Render template with values (use '|' to avoid slash conflicts)
          sed -e "s|__ENV__|${ENV}|g" \
              -e "s|__ECR__|${ECR_REPO_URL}|g" \
              -e "s|__TAG__|${TAG_TO_DEPLOY}|g" \
              -e "s|__REGION__|${AWS_REGION}|g" \
              -e "s|__BUCKET__|${BACKUP_BUCKET}|g" /tmp/remote.sh > /tmp/remote.rendered.sh

          aws ssm send-command \
            --document-name "AWS-RunShellScript" \
            --instance-ids "$INSTANCE_ID" \
            --comment "Deploy containers with rollback logic" \
            --parameters commands="$(jq -Rs . /tmp/remote.rendered.sh)" \
            --timeout-seconds 1200 \
            --region "$AWS_REGION"
